A quadcopter is a flying machine with four propellers controlled either autonomously (programmed with a fix flight routine) or via a remote control.

This first article (hopefully of a series) covers a brief overview of how they work, how to build one controlled by a Raspberry Pi, information about where to get all the bits you need, and how to bolt them all together physically, electronically and in software.  The result should be a quadcopter which can take-off, hover, and land autonomously (and with care!)

Future articles cover more details on testing and tuning this basic quad including code enhancements to allow lateral movement, a Raspberry Pi remote control, and perhaps future developments covering GPS tracking.

Parts of a quadcopter

First a quick breakdown of all the parts that make up a quadcopter.


    There are 4 propeller blades, made of wood, plastic or even carbon fibre.  Two of the four are designed to rotate clock-wise; the other two, ant-clockwise to provide lift.  Blades which are designed to move the same way are placed diagonally opposite on the frame.  Organising the blades like this helps stop the quadcopter spinning in the air (this spinning is called yaw).  By applying different power to each propeller, and hence different amounts of lift to corners of the quadcopter, it’s possible to not only get a quadcopter to take-off, hover and land, but also by tilting it, move horizontally and turn corners.
    Each propeller has it’s own DC brushless motor.  These motors can be wired to rotate clockwise or anti-clockwise to match the propeller connected to them.  A brushless motor works much like a servo or a bi-polar stepper motor.  It has coils in three groups around the body (called the stator), and groups of magnets attached to the propellor shaft (called the rotor).  To move the blades, power is applied to one group of the coils, and the rotor magnets are attracted to that coil, moving round.  If then that coil is turned off, and the next one powered up, the rotors moves around to the next coil.  Keep repeating this around the three coils in sequence results in the motor rototating; the faster you swap between the three powered coils, the faster the motors rotates.  This make the motors suitable for ‘digital’ control – the direction and speed of movement of the propeller blades exactly matches the sequence and rate power pulses are applied to the coils.  These motors take a lot of power to spin the propeller blades fast enough to force enough air down to make the quadcopter take-off – far more power than a Raspberry Pi can provide – so an Electronic Speed Controller (aka ESC) bridges that gap.  It translates between a Pulse Width Modulation (PWM) control signal from the Raspberry Pi and converts it to three high-current signals, one for each coil of the motors. They are the small white objects velcro’d under the arms of the quadcopter.  –  more on that later.

    Next there are sensors, attached to the breadboard on the shelf below the Raspberry Pi;  these provide information to the Raspberry Pi about rocking and rolling in three dimensions from a gyroscope, and information about acceleration forward, backwards, left, right, up and down.  The sensors connect to the Raspberry Pi GPIO I2C pins.  Also on the breadboard is a beeper so I can here what the quadcopter thinks it’s doing, and the connectors from the Raspberry Pi PWM signal to the ESCs.


    The power for everything comes from a single Lithium Polymer battery, providing 11.1 volts, up to a peak current of 100 amperes, with the full-charge of 3300 mAh thus supplying three point three amps for an hour or one hundred amps for two minutes or anywhere in between.  This is a powerful and dangerous beast, yet it only weighs 250 grams.  It requires a special charger – if not used, a LiPo battery can easily become a LiPo bomb – beware.  There is a regulator on the breadboard to take power from the battery and produce the five volts for the Raspberry Pi, and also provide a degree of protection from the vast power surges the motors draw from the battery.

And that just leaves the beating heart of the quadcopter itself; the Raspberry Pi.  Using Python code, it reads the sensors, compares them to a desired action (for example take-off, hover, land) set either in code or from a remote control, converts the difference between what the quad is doing (from the sensors), and what it should be (from the code or remote control), and changes the power to each of the  motors individually so that the desired action and sensor outputs match.

Creating your quadcopter

First and foremost, flying machines and boats are female and they have names; mine is called Phoebe (“Fee-Bee”).  Choose a name for yours and treat her well, and the chances are she’ll reciprocate!

Phoebe’s body, arms, legs, blades, motors, ESCs and batteries are from kits.  Total cost is about £250 – together with a Raspberry Pi, and other accoutrements, the total cost is perhaps £300 – £350.  Not cheap for something which certainly at the start has a preference to crash rather than fly!

A complete bill of materials (BOM) is available here.

I’ve actually upgraded my motors to higher power, lighter weight varieties, but this is absolutely not necessary – they equipment provided by the kits is excellent.  Upgrading components for weight reduction / power efficiency and strength is definitely an afterthought once the basics are working.

The Raspberry Pi is a model A, chosen for lower weight, and lower power consumption; these are factors reflected through other pieces of the design.  I’ve removed the audio and video outputs, and use a micro-SD card adapter from the guys at Pimoroni – all in the name of weight saving.

The Raspberry Pi case is a variant of the Pimoroni PiBow model B case with a couple of levels removed, and some holes sealed for reduced weight and increased strength (protection from crashes!).  I’ve posted the design for these here - Phenoptix do a great job of laser cutting 3mm acrylic at a very reasonable price – highly recommended.

Talking to Phoebe

Whether Phoebe is autonomous, or remote controlled, someone needs to talk to her to tell her what to do.  To that end, Phoebe runs a Wireless Access Point (WAP) so another computer can join her private network, and either SSH in, or provide remote control commands.  You can see how I did this here.

For initial testing, the WAP function isn’t necessary – any household wireless network will do, but as your quadcopter comes to life, you’ll want to be doing your testing away from animals / children and other valuables you don’t want damaged (like yourself), and having a WAP means you can take the testing out into the garden or local park or field – for the benefit of Londoners, here’s a picture of a “field”.

Presenting Phoebe’s Python Programming

The final step is obviously the most important; once you have a physical quadcopter, with associated blades, motors, ESCs, power and circuitry, we use Python code to glue all the pieces together.  I’m not going to go into this blow by blow here as the code is available here, and it should be self-documenting – there are more lines of explanatory comments than there are lines of code actually doing something constructive!

    The I2C class provides a programming interface to read and write data from the sensors
    Built on that, the MPU6050 class configures the sensors and then provides API access to reading the data, and converting the values from the sensor into meaningful values humans would understand (like degrees per second rotation or meters per second per second acceleration).
    The QUAD class handles the PWM for each blade handling initialization, and setting the PWM data to control the propeller blade spin speeds
    The PID class is the jigsaw glue, and the core of the development and testing.  It’s the understanding of this which makes configuring a quadcopter both exciting and scary!  It’s worth an article in its own right – for now there’s a brief overview and what they do and how at the end.
    There are utility functions for processing the startup command line parameters, signal handling (the panic button ctrl-C), and some shutdown code
    Last, but not least, there’s the big “while keep_looping:” loop which checks on what it should be doing (take-off, hover, land, etc), reads the sensors, runs the PIDs, updates the PWMs and returns to the start one hundred times a second!

The PID

A PID is a relatively small, simple piece of code used to achieve quite a complex task: it is fed a “target” value and an “input” value.  The difference between these is the “error”.  The PID processes this “error”, and produces an “output” which aims to shrink the difference between “target” and “input” to zero.  It does this repeatedly constantly updating the “output”, yet without any idea of what “input”, “output” or “target” actually mean in it’s real world context as the core of a quadcopter: weight, gravity, wind strength, RC commands, location,  momentum, speed and all the other factors which are critical to a  quadcopters.

In the context of a quadcopter, “target” is a flight command – hover, take-off, land, move forwards; “input” is sensor data; the “output” is the PWM pulse size for the motors.

Phoebe has 4 PIDs running currently – pitch, roll, yaw and vertical speed – these are the bare minimum needed for an orderly takeoff, hover and landing.

The PIDs magic is that it doesn’t have any complex math(s) connecting power, weight, blade spin rates, gravity, wind-speed, imbalanced frame, poor center of gravity or the many other factors that perturb the perfect flight modelled by a pure math(s) equation.

Instead, it does this by repeated rapid reestimation of what the current best guess “output” must be based only on the “target” and the “input”.

    The “P” of PID stands for proportional – each time the PID is called, its “output” is just some factor times the “error” – in quadcopter context, this corrects immediate problems like this is the direct approach to keeping the absolute “error” to zero.
    The “I” of PID stands for integral – each time the PID is called, the “error” is added to a grand total of errors to produce an output with the intent that over time, the total “error” remains at zero – in quadcopter context, this aims to produce long term stability deals with long term problems like imbalance in the physical frame, motor and blade power, and wind.
    The “D” of PID stands for differential – each time the PID is called, the difference in error since last time is used to generate the output – if the “error” is worse than last time, the PID “D” output is higher; this aims to produce a predictive approach to error correction.

The results of all three are added together to give an overall output, and then depending on the purpose of the PID, applied to each of the blades appropriately.

It sounds like magic doesn’t it?  And to some extent it is!  You see every PID has three configurable gain factors configured for it, one each for “P”, “I”, and “D”.  So in my case, I have twelve different gain factors.  These are magic numbers, which if too small do nothing, if too large cause chaos, and if applied wrongly cause catastrophe.  My next article will cover this in much more detail, both how they work and how to tune the gains; in the meantime, get on with building your own quadcopter – the PID gains in the code I’ve supplied should be a reasonable starting point for yours.

Flying Pheobe

At the moment, it’s simple but dangerous!

    Put Phoebe on the ground, place a flat surface across her propeller tips, put a spirit level on that surface, and make sure she’s on absolute horizontal by putting padding under her feet – this is absolutely critical if you don’t want her to drift in flight – we’ll fix this in another article with some more PIDs
    Connect the LiPo battery – the ESCs will start beeping loudly – ignore them
    Wait until the WiFi dongle starts to flash – that means Phoene’s WAP is working
    Connect via SSH / rlogin from a client – another Raspberry Pi, iPad etc who’ve joined Phoebe’s network
    cd to the directory you’ve placed Phoebe’s code
    Run

sudo python ./phoebe.py -c
sudo python ./phoebe.py -c -t 550 -v

    -c calibrates the sensors to the flat surface she’s on
    -t 550 sets up the blades to just under take-off speed
    -v runs the video camera while she’s in flight.

There are other options you can find by just typing

sudo python ./phoebe.py

Enjoy but be careful
